

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Clustering &mdash; PCA-python  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Cluster-biased PCA" href="cluster-biased-pca.html" />
    <link rel="prev" title="Principal Component Analysis" href="PCA.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> PCA-python
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="PCA.html">Principal Component Analysis</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Clustering</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#clustering-functions">Clustering functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#auxiliary-functions">Auxiliary functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cluster-biased-pca.html">Cluster-biased PCA</a></li>
<li class="toctree-l1"><a class="reference internal" href="manifold-dimensionality.html">Manifold dimensionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="train-test-select.html">Train and test data selection</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/train-test-selection.html">Selecting train and test data</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PCA-python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Clustering</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user/clustering.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-PCA.clustering"></span><div class="section" id="clustering">
<h1>Clustering<a class="headerlink" href="#clustering" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">clustering.py</span></code> module contains functions for classifying data sets into local clusters and performing some basic operations on clusters [1], [2].</p>
<div class="section" id="clustering-functions">
<h2>Clustering functions<a class="headerlink" href="#clustering-functions" title="Permalink to this headline">¶</a></h2>
<p>Each function that clusters the data set returns a vector <code class="docutils literal notranslate"><span class="pre">idx</span></code> of type <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> of size <code class="docutils literal notranslate"><span class="pre">(n_observations,)</span></code> that specifies classification of each observation from the original data set <code class="docutils literal notranslate"><span class="pre">X</span></code> to a local cluster.</p>
<a class="reference internal image-reference" href="../_images/clustering-idx.png"><img alt="../_images/clustering-idx.png" class="align-center" src="../_images/clustering-idx.png" style="width: 400px;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The first cluster has index <code class="docutils literal notranslate"><span class="pre">0</span></code> within all <code class="docutils literal notranslate"><span class="pre">idx</span></code> vectors returned. When verbose information is printed with <code class="docutils literal notranslate"><span class="pre">verbose=True</span></code> during function execution or on the plots the cluster numeration starts with <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</div>
<dl class="py function">
<dt id="PCA.clustering.variable_bins">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">variable_bins</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.variable_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>This function does clustering by dividing a variable vector <code class="docutils literal notranslate"><span class="pre">var</span></code> into
bins of equal lengths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> – vector of variable values.</p></li>
<li><p><strong>k</strong> – number of clusters to partition the data.</p></li>
<li><p><strong>verbose</strong> – (optional)
boolean for printing clustering details.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if number of clusters <code class="docutils literal notranslate"><span class="pre">k</span></code> is not a positive integer.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>idx</strong> - vector of indices classifying observations to clusters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># var_min                                                var_max</span>
<span class="c1">#   |----------|----------|----------|----------|----------|</span>
<span class="c1">#      bin 1      bin 2      bin 3       bin 4     bin 5</span>
</pre></div>
</div>
<dl class="py function">
<dt id="PCA.clustering.predefined_variable_bins">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">predefined_variable_bins</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">split_values</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.predefined_variable_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>This function does clustering by dividing a variable vector <code class="docutils literal notranslate"><span class="pre">var</span></code> into
bins such that the split is done at values specified in the <code class="docutils literal notranslate"><span class="pre">split_values</span></code>
list.</p>
<p><em>Note:</em>
When a split is performed at a given <code class="docutils literal notranslate"><span class="pre">value_i</span></code>, the observation in <code class="docutils literal notranslate"><span class="pre">var</span></code>
that takes exactly that value is assigned to the newly created bin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> – vector of variable values.</p></li>
<li><p><strong>split_values</strong> – list containing values at which the split to bins should be performed.</p></li>
<li><p><strong>verbose</strong> – (optional)
boolean for printing clustering details.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if any value within <code class="docutils literal notranslate"><span class="pre">split_values</span></code> is not within the range of
vector <code class="docutils literal notranslate"><span class="pre">var</span></code> values.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>idx</strong> - vector of indices classifying observations to clusters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># var_min     value_1              value_2      value_3  var_max</span>
<span class="c1">#   |----------|--------------------|------------|---------|</span>
<span class="c1">#       bin 1           bin 2            bin 3      bin 4</span>
</pre></div>
</div>
<dl class="py function">
<dt id="PCA.clustering.mixture_fraction_bins">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">mixture_fraction_bins</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Z</span></em>, <em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">Z_stoich</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.mixture_fraction_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>This function does clustering by dividing a mixture fraction vector
<code class="docutils literal notranslate"><span class="pre">Z</span></code> into bins of equal lengths. The vector is first split to lean and rich
side and then the sides get divided further into clusters. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is even,
this function will always create equal number of clusters on the lean and
rich side. When <code class="docutils literal notranslate"><span class="pre">k</span></code> is odd, there will be one more cluster on the rich side
compared to the lean side.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Z</strong> – vector of mixture fraction values.</p></li>
<li><p><strong>k</strong> – number of clusters to partition the data.</p></li>
<li><p><strong>Z_stoich</strong> – stoichiometric mixture fraction.</p></li>
<li><p><strong>verbose</strong> – (optional)
boolean for printing clustering details.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if number of clusters <code class="docutils literal notranslate"><span class="pre">k</span></code> is not a positive integer.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>idx</strong> - vector of indices classifying observations to clusters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Z_min           Z_stoich                                 Z_max</span>
<span class="c1">#   |-------|-------|------------|------------|------------|</span>
<span class="c1">#     bin 1   bin 2     bin 3        bin 4         bin 5</span>
</pre></div>
</div>
<dl class="py function">
<dt id="PCA.clustering.pc_source_bins">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">pc_source_bins</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pc_source</span></em>, <em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">zero_offset_percentage</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">split_at_zero</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.pc_source_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>This function does clustering by dividing a PC-source vector
<code class="docutils literal notranslate"><span class="pre">pc_source</span></code> into bins. By default, it finds one cluster between a negative and
a positive offset from PC-source=0. The offset is computed from the input
parameter <code class="docutils literal notranslate"><span class="pre">zero_offset_percentage</span></code> which specifies a percentage of the range
<code class="docutils literal notranslate"><span class="pre">pc_source_max</span> <span class="pre">-</span> <span class="pre">pc_source_min</span></code>. Further clusters are found by clustering
positive and negative PC-sources alternatingly into bins of equal lengths.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">split_at_zero</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the partitioning will always find one
cluster that is between <code class="docutils literal notranslate"><span class="pre">-offset</span></code> and 0 and another cluster that is between
0 and <code class="docutils literal notranslate"><span class="pre">+offset</span></code>.</p>
<p>Due to the nature of this clustering technique, the smallest allowed number
of clusters is 3 if <code class="docutils literal notranslate"><span class="pre">split_at_zero=False</span></code>. This is to assure that there are
at least there three clusters: with high negative values, with close to zero
values, with high positive values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">split_at_zero=True</span></code>, the smallest allowed number of clusters is 4. This
is to assure that there are at least four clusters: with high negative
values, with negative values close to zero, with positive values close to
zero and with high positive values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pc_source</strong> – vector of variable values.</p></li>
<li><p><strong>k</strong> – number of clusters to partition the data.
Cannot be smaller than 3 if <code class="docutils literal notranslate"><span class="pre">split_at_zero=False</span></code> or smaller
than 4 if <code class="docutils literal notranslate"><span class="pre">split_at_zero=True</span></code>.</p></li>
<li><p><strong>zero_offset_percentage</strong> – (optional)
percentage of <code class="docutils literal notranslate"><span class="pre">|pc_source_max</span> <span class="pre">-</span> <span class="pre">pc_source_min|</span></code> to take as the
<code class="docutils literal notranslate"><span class="pre">offset</span></code> value.</p></li>
<li><p><strong>split_at_zero</strong> – (optional)
boolean specifying whether partitioning should be done at PC-source=0.</p></li>
<li><p><strong>verbose</strong> – (optional)
boolean for printing clustering details.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – if number of clusters <code class="docutils literal notranslate"><span class="pre">k</span></code> is not an integer or smaller than 3 when
<code class="docutils literal notranslate"><span class="pre">split_at_zero=False</span></code> or smaller than 4 when <code class="docutils literal notranslate"><span class="pre">split_at_zero=True</span></code>.</p></li>
<li><p><strong>ValueError</strong> – if PC-source vector <code class="docutils literal notranslate"><span class="pre">pc_source</span></code> has only non-negative or only
non-positive values. For such vectors it is recommended to use
<code class="docutils literal notranslate"><span class="pre">predefined_variable_bins</span></code> function instead.</p></li>
<li><p><strong>ValueError</strong> – if the requested offset from zero crosses the minimum or maximum value
of the PC-source vector <code class="docutils literal notranslate"><span class="pre">pc_source</span></code>. If that is the case, it is
recommended to lower the <code class="docutils literal notranslate"><span class="pre">zero_offset_percentage</span></code> value.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>idx</strong> - vector of indices classifying observations to clusters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#                  -offset         +offset</span>
<span class="c1">#                           \    /</span>
<span class="c1"># pc_source_min             | 0 |                          pc_source_max</span>
<span class="c1">#     |----------|----------|---|----------|----------|----------|</span>
<span class="c1">#         bin 1      bin 2   bin 3  bin 4      bin 5      bin 6</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#                  -offset     0     +offset</span>
<span class="c1">#                           \  |   /</span>
<span class="c1"># pc_source_min             |  |  |                          pc_source_max</span>
<span class="c1">#     |----------|----------|--|--|----------|----------|----------|</span>
<span class="c1">#        bin 1      bin 2    /   \   bin 5      bin 6      bin 7</span>
<span class="c1">#                           /     \</span>
<span class="c1">#                       bin 3       bin 4</span>
</pre></div>
</div>
<dl class="py function">
<dt id="PCA.clustering.vqpca">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">vqpca</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">n_pcs</span></em>, <em class="sig-param"><span class="n">scaling_criteria</span></em>, <em class="sig-param"><span class="n">idx_0</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">maximum_number_of_iterations</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.vqpca" title="Permalink to this definition">¶</a></dt>
<dd><p>This function performs Vector Quantization clustering using
Principal Component Analysis. VQPCA assigns observations to a particular
cluster based on the minimum reconstruction error from PCA approximation
with <code class="docutils literal notranslate"><span class="pre">n_pcs</span></code> number of Principal Components. This is an iterative
procedure in which the reconstruction errors are evaluated for every
observation as if that observation belonged to cluster <em>j</em> and next,
the observation is assigned to that cluster for which the error was smallest.</p>
<p><em>Note:</em>
VQPCA algorithm will center the global data set <code class="docutils literal notranslate"><span class="pre">X</span></code> by mean and scale by
the scaling specified in the <code class="docutils literal notranslate"><span class="pre">scaling_criteria</span></code> parameter. Data in local
clusters will be centered by the mean but will not be scaled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – raw global data set, uncentered and unscaled.</p></li>
<li><p><strong>k</strong> – number of clusters to partition the data.</p></li>
<li><p><strong>n_pcs</strong> – number of Principal Components (PCs) that will be used to reconstruct the data
at each iteration.</p></li>
<li><p><strong>scaling_criteria</strong> – scaling critertion for the global data set.</p></li>
<li><p><strong>idx_0</strong> – (optional)
user-supplied initial <code class="docutils literal notranslate"><span class="pre">idx</span></code> for initializing the centroids. By default
random intialization is performed.</p></li>
<li><p><strong>maximum_number_of_iterations</strong> – (optional)
the maximum number of iterations that the algorithm will loop through.</p></li>
<li><p><strong>verbose</strong> – (optional)
boolean for printing clustering details.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the number of observations in the data set <code class="docutils literal notranslate"><span class="pre">X</span></code> does not match the
number of elements in the <code class="docutils literal notranslate"><span class="pre">idx_0</span></code> vector.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>idx</strong> - vector of indices classifying observations to clusters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<p>VQPCA algorithm used here was first proposed in [parente2009identification]. The general scheme for the iterative procedure is presented below:</p>
<a class="reference internal image-reference" href="../_images/clustering-vqpca.png"><img alt="../_images/clustering-vqpca.png" class="align-center" src="../_images/clustering-vqpca.png" style="width: 700px;" /></a>
</div>
<div class="section" id="auxiliary-functions">
<h2>Auxiliary functions<a class="headerlink" href="#auxiliary-functions" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="PCA.clustering.degrade_clusters">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">degrade_clusters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.degrade_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function renumerates clusters if either of these two cases is true:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">idx</span></code> is composed of non-consecutive integers, or</p></li>
<li><p>the smallest cluster number in <code class="docutils literal notranslate"><span class="pre">idx</span></code> is not equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
</ul>
<p><strong>Example:</strong></p>
<p>Starting with an <code class="docutils literal notranslate"><span class="pre">idx</span></code> that is the following:
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">5,</span> <span class="pre">10]</span></code> this function turns this <code class="docutils literal notranslate"><span class="pre">idx</span></code> to:
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>, where clusters are numbered with consecutive integers.</p>
<p>Alternatively, if <code class="docutils literal notranslate"><span class="pre">idx</span></code> is: <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">3]</span></code> this function turns
this <code class="docutils literal notranslate"><span class="pre">idx</span></code> to: <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2]</span></code> so that the smallest cluster number
is equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> – raw vector of indices classifying observations to clusters.</p></li>
<li><p><strong>verbose</strong> – (optional)
boolean for printing clustering details.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>idx_degraded</strong> degraded vector of indices classifying observations to clusters. The first cluster has index 0.</p></li>
<li><p><strong>k_update</strong> - the updated number of clusters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PCA.clustering.flip_clusters">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">flip_clusters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">dictionary</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.flip_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function flips the cluster labelling according to instructions provided
in the dictionary. For a <code class="docutils literal notranslate"><span class="pre">dictionary</span> <span class="pre">=</span> <span class="pre">{key</span> <span class="pre">:</span> <span class="pre">value}</span></code>, a cluster with a
number <code class="docutils literal notranslate"><span class="pre">key</span></code> will get a number <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> – vector of indices classifying observations to clusters.
The first cluster has index 0.</p></li>
<li><p><strong>dictionary</strong> – a dictionary specifying the cluster numeration flipping instructions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>flipped_idx</strong> - vector of indices classifying observations to clusters. The first cluster has index 0.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PCA.clustering.get_centroids">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">get_centroids</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.get_centroids" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the centroids for the clustering specified in the
<code class="docutils literal notranslate"><span class="pre">idx</span></code> vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – data set for computing the cluster centroids.</p></li>
<li><p><strong>idx</strong> – vector of indices classifying observations to clusters.
The first cluster has index 0.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the number of observations in the data set <code class="docutils literal notranslate"><span class="pre">X</span></code> does not match the
number of elements in the <code class="docutils literal notranslate"><span class="pre">idx</span></code> vector.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>centroids</strong> - matrix of cluster centroids. It has size <code class="docutils literal notranslate"><span class="pre">k</span></code> times number of observations.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PCA.clustering.get_partition">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">get_partition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.get_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>This function partitions the observations from the original global data
set <code class="docutils literal notranslate"><span class="pre">X</span></code> into local clusters according to <code class="docutils literal notranslate"><span class="pre">idx</span></code> provided. It returns a
tuple of three variables <code class="docutils literal notranslate"><span class="pre">(data_in_clusters,</span> <span class="pre">data_idx_in_clusters,</span> <span class="pre">k_new)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">data_in_clusters</span></code> are the original observations from <code class="docutils literal notranslate"><span class="pre">X</span></code> divided
into clusters, <code class="docutils literal notranslate"><span class="pre">data_idx_in_clusters</span></code> are the indices of the original
observations divided into clusters. If any cluster is empty or has less
observations assigned to it that the number of variables, that cluster will
be removed and the observations that were assigned to it will not appear
in <code class="docutils literal notranslate"><span class="pre">data_in_clusters</span></code> nor in <code class="docutils literal notranslate"><span class="pre">data_idx_in_clusters</span></code>. The new number of
clusters <code class="docutils literal notranslate"><span class="pre">k_new</span></code> is computed taking into account any possibly removed
clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – data set to partition.</p></li>
<li><p><strong>idx</strong> – vector of indices classifying observations to clusters.
The first cluster has index 0.</p></li>
<li><p><strong>verbose</strong> – (optional)
boolean for printing details.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>data_in_clusters</strong> - list of <code class="docutils literal notranslate"><span class="pre">k_new</span></code> arrays that contains original data set observations in each cluster.</p></li>
<li><p><strong>data_idx_in_clusters</strong> - list of <code class="docutils literal notranslate"><span class="pre">k_new</span></code> arrays that contains indices of the original data set observations in each cluster.</p></li>
<li><p><strong>k_new</strong> - the updated number of clusters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PCA.clustering.get_populations">
<code class="sig-prename descclassname">PCA.clustering.</code><code class="sig-name descname">get_populations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PCA.clustering.get_populations" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes populations (number of observations) in clusters
specified in the <code class="docutils literal notranslate"><span class="pre">idx</span></code> vector. As an example, if there are 100
observations in the first cluster and 500 observations in the second cluster
this function will return a list: <code class="docutils literal notranslate"><span class="pre">[100,</span> <span class="pre">500]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong> – vector of indices classifying observations to clusters.
The first cluster has index 0.</p></li>
<li><p><strong>verbose</strong> – (optional)
boolean for printing details.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>populations</strong> - list of cluster populations. Each entry referes to one cluster ordered according to <code class="docutils literal notranslate"><span class="pre">idx</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cluster-biased-pca.html" class="btn btn-neutral float-right" title="Cluster-biased PCA" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="PCA.html" class="btn btn-neutral float-left" title="Principal Component Analysis" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Elizabeth Armstrong, Kamila Zdybal

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>